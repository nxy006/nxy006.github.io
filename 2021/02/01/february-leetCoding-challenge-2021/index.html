<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Not A Number</title>

    
    
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/github-markdown.css">

    
    
<link rel="stylesheet" href="/css/hlj/stackoverflow-light.css">

    
<script src="/js/highlight.pack.js"></script>

<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="sidebar">
    <div class="sidebar-title">
        <!--img src="/images/logo@2x.png" style="width:127px;"-->
        <a href="https://nxy006.github.io"><h1>Not A Number</h1></a>
    </div>
    
    <div class="sidebar-menu">
        <div><a href="/archives">归档</a></div>
    </div>
    
    <div class="sidebar-footer">
        <!-- <iframe 
            frameborder="0"
            border="1"
            marginwidth="0"
            marginheight="0"            
            width=280
            height=100
            src="//music.163.com/outchain/player?type=2&id=464916877&auto=true&height=60">
        </iframe> -->
        <div class="sidebar-background">Background: <a href="https://pixabay.com/zh/photos/snow-ice-winter-cold-snowy-nature-5852352" target="_blank">雪 冰 冬天</a></div>
        <div class="sidebar-licenses">Licenses: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC 4.0</a>
            <span class="cc-license-icons">
                <span id="cc-logo" class="icon"><img width="15px" alt="cc logo" src="https://creativecommons.org/images/deed/cc_icon_white_x2.png"></span>
                <span id="cc-attribution" class="icon"><img width="15px" src="https://creativecommons.org/images/deed/attribution_icon_white_x2.png"></span>
                <span id="cc-icon-nc" class="icon"><img width="15px" src="https://creativecommons.org/images/deed/nc_white_x2.png"></span>
                <span id="cc-icon-sa" class="icon"><img width="15px" src="https://creativecommons.org/images/deed/sa_white_x2.png"></span>
            </span>
        </div>
        <hr/>
        <div>©2021. All rights reserved.</div>
        <div>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>, custom theme</div>
    </div>
</div>
    <div class="content">
        

<div class="article">
    <div class="title"><a href="/2021/02/01/february-leetCoding-challenge-2021/">February LeetCoding Challenge 2021 解题报告</a></div>
    <div class="time">创建时间：2021-02-01 / 更新时间：2021-05-19</div>
    <div class="article-toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Number-of-1-Bits"><span class="toc-text">1. Number of 1 Bits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Trim-a-Binary-Search-Tree"><span class="toc-text">2. Trim a Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Linked-List-Cycle"><span class="toc-text">3. Linked List Cycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Longest-Harmonious-Subsequence"><span class="toc-text">4. Longest Harmonious Subsequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Simplify-Path"><span class="toc-text">5. Simplify Path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Binary-Tree-Right-Side-View"><span class="toc-text">6. Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Shortest-Distance-to-a-Character"><span class="toc-text">7. Shortest Distance to a Character</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Peeking-Iterator"><span class="toc-text">8. Peeking Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Convert-BST-to-Greater-Tree"><span class="toc-text">9. Convert BST to Greater Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Copy-List-with-Random-Pointer"><span class="toc-text">10. Copy List with Random Pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Valid-Anagram"><span class="toc-text">11. Valid Anagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Number-of-Steps-to-Reduce-a-Number-to-Zero"><span class="toc-text">12. Number of Steps to Reduce a Number to Zero</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Shortest-Path-in-Binary-Matrix"><span class="toc-text">13. Shortest Path in Binary Matrix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Is-Graph-Bipartite"><span class="toc-text">14. Is Graph Bipartite?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-The-K-Weakest-Rows-in-a-Matrix"><span class="toc-text">15. The K Weakest Rows in a Matrix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Letter-Case-Permutation"><span class="toc-text">16. Letter Case Permutation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Container-With-Most-Water"><span class="toc-text">17. Container With Most Water</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Arithmetic-Slices"><span class="toc-text">18. Arithmetic Slices</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Minimum-Remove-to-Make-Valid-Parentheses"><span class="toc-text">19. Minimum Remove to Make Valid Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Roman-to-Integer"><span class="toc-text">20. Roman to Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Broken-Calculator"><span class="toc-text">21. Broken Calculator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Longest-Word-in-Dictionary-through-Deleting"><span class="toc-text">22. Longest Word in Dictionary through Deleting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Search-a-2D-Matrix-II"><span class="toc-text">23. Search a 2D Matrix II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Score-of-Parentheses"><span class="toc-text">24. Score of Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Shortest-Unsorted-Continuous-Subarray"><span class="toc-text">25. Shortest Unsorted Continuous Subarray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Validate-Stack-Sequences"><span class="toc-text">26. Validate Stack Sequences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Divide-Two-Integers"><span class="toc-text">27. Divide Two Integers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Maximum-Frequency-Stack"><span class="toc-text">28. Maximum Frequency Stack</span></a></li></ol>
    </div>
    
    <div class="article-content markdown-body">
        <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/explore/challenge/card/february-leetcoding-challenge-2021/">February LeetCoding Challenge 2021</a></p>
<p><strong>Week 1: February 1st - February 7th</strong></p>
<ol>
<li>Squirrel Simulation <code>Premium</code></li>
<li><a href="#1-Number-of-1-Bits">Number of 1 Bits</a></li>
<li><a href="#2-Trim-a-Binary-Search-Tree">Trim a Binary Search Tree</a></li>
<li><a href="#3-Linked-List-Cycle">Linked List Cycle</a></li>
<li><a href="#4-Longest-Harmonious-Subsequence">Longest Harmonious Subsequence</a></li>
<li><a href="#5-Simplify-Path">Simplify Path</a></li>
<li><a href="#6-Binary-Tree-Right-Side-View">Binary Tree Right Side View</a></li>
<li><a href="#7-Shortest-Distance-to-a-Character">Shortest Distance to a Character</a></li>
</ol>
<p><strong>Week 2: February 8th - February 14th</strong></p>
<ol>
<li>Number of Distinct Islands <code>Premium</code></li>
<li><a href="#8-Peeking-Iterator">Peeking Iterator</a></li>
<li><a href="#9-Convert-BST-to-Greater-Tree">Convert BST to Greater Tree</a></li>
<li><a href="#10-Copy-List-with-Random-Pointer">Copy List with Random Pointer</a></li>
<li><a href="#11-Valid-Anagram">Valid Anagram</a></li>
<li><a href="#12-Number-of-Steps-to-Reduce-a-Number-to-Zero">Number of Steps to Reduce a Number to Zero</a></li>
<li><a href="#13-Shortest-Path-in-Binary-Matrix">Shortest Path in Binary Matrix</a></li>
<li><a href="#14-Is-Graph-Bipartite">Is Graph Bipartite?</a></li>
</ol>
<p><strong>Week 3: February 15th - February 21st</strong></p>
<ol>
<li>Kill Process <code>Premium</code></li>
<li><a href="#15-The-K-Weakest-Rows-in-a-Matrix">The K Weakest Rows in a Matrix</a></li>
<li><a href="#16-Letter-Case-Permutation">Letter Case Permutation</a></li>
<li><a href="#17-Container-With-Most-Water">Container With Most Water</a></li>
<li><a href="#18-Arithmetic-Slices">Arithmetic Slices</a></li>
<li><a href="#19-Minimum-Remove-to-Make-Valid-Parentheses">Minimum Remove to Make Valid Parentheses</a></li>
<li><a href="#20-Roman-to-Integer">Roman to Integer</a></li>
<li><a href="#21-Broken-Calculator">Broken Calculator</a></li>
</ol>
<p><strong>Week 4: February 22nd - February 28th</strong></p>
<ol>
<li>Find the Celebrity <code>Premium</code></li>
<li><a href="#22-Longest-Word-in-Dictionary-through-Deleting">Longest Word in Dictionary through Deleting</a></li>
<li><a href="#23-Search-a-2D-Matrix-II">Search a 2D Matrix II</a></li>
<li><a href="#24-Score-of-Parentheses">Score of Parentheses</a></li>
<li><a href="#25-Shortest-Unsorted-Continuous-Subarray">Shortest Unsorted Continuous Subarray</a></li>
<li><a href="#26-Validate-Stack-Sequences">Validate Stack Sequences</a></li>
<li><a href="#27-Divide-Two-Integers">Divide Two Integers</a></li>
<li><a href="#28-Maximum-Frequency-Stack">Maximum Frequency Stack</a></li>
</ol>
<br/>

<h2 id="1-Number-of-1-Bits"><a href="#1-Number-of-1-Bits" class="headerlink" title="1. Number of 1 Bits"></a>1. Number of 1 Bits</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-1-bits/">191. Number of 1 Bits</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>计算一个无符号整数的二进制表示包含多少个 <code>1</code> ，注意 java 不支持无符号整数因此可能传入负数。</p>
<p><strong>题目解答：</strong></p>
<p>常规解法，逐位判断（传入负数时，要转换为补码）。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-comment">// you need to treat n as an unsigned value</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">int</span> cnt = n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;
            n = Integer.MAX_VALUE + n + <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> ((n&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) cnt++;
            n &gt;&gt;= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> cnt;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="2-Trim-a-Binary-Search-Tree"><a href="#2-Trim-a-Binary-Search-Tree" class="headerlink" title="2. Trim a Binary Search Tree"></a>2. Trim a Binary Search Tree</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>处理一个二叉搜索树，将在给定取值范围外的节点移除，但注意剩余节点的相对位置不能改变。</p>
<p><strong>题目解答：</strong></p>
<p>为符合取值范围的节点查找其子节点即可，递归实现。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for a binary tree node.</span>
<span class="hljs-comment"> * public class TreeNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     TreeNode left;</span>
<span class="hljs-comment"> *     TreeNode right;</span>
<span class="hljs-comment"> *     TreeNode() &#123;&#125;</span>
<span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span>
<span class="hljs-comment"> *         this.val = val;</span>
<span class="hljs-comment"> *         this.left = left;</span>
<span class="hljs-comment"> *         this.right = right;</span>
<span class="hljs-comment"> *     &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;
            root.left = trimBST(root.left, low, high);
            root.right = trimBST(root.right, low, high);
            <span class="hljs-keyword">return</span> root;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; low) &#123;
            <span class="hljs-keyword">return</span> trimBST(root.right, low, high);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> trimBST(root.left, low, high);
        &#125;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="3-Linked-List-Cycle"><a href="#3-Linked-List-Cycle" class="headerlink" title="3. Linked List Cycle"></a>3. Linked List Cycle</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>经典题目，判断一个链表内是否存在循环。</p>
<p><strong>题目解答：</strong></p>
<p>常规解法一般是记录已访问的节点列表（或标记这些节点的 <code>val</code> 为特殊值），如果重复访问即说明存在循环。一种空间复杂度 O(1) 解法是，双指针以不同的速度扫描，如果遇到同一节点则说明存在循环。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * class ListNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     ListNode next;</span>
<span class="hljs-comment"> *     ListNode(int x) &#123;</span>
<span class="hljs-comment"> *         val = x;</span>
<span class="hljs-comment"> *         next = null;</span>
<span class="hljs-comment"> *     &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        
        ListNode l = head, r = head.next;
        <span class="hljs-keyword">while</span>(l != <span class="hljs-keyword">null</span> &amp;&amp; r != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            l = l.next;
            r = r.next;
            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) r = r.next;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="4-Longest-Harmonious-Subsequence"><a href="#4-Longest-Harmonious-Subsequence" class="headerlink" title="4. Longest Harmonious Subsequence"></a>4. Longest Harmonious Subsequence</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-harmonious-subsequence/">594. Longest Harmonious Subsequence594. Longest Harmonious Subsequence</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>定义最大最小值的差值恰好为 1 的序列为和谐（<em>harmonious</em>）序列，给出字符串，求最长和谐子序列长度，子序列不要求连续。</p>
<p><strong>题目解答：</strong></p>
<p>本题实际与顺序无关，排序后直接找值为 n 与 n+1 且均不为零，的最大计数之和。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        Arrays.sort(nums);
        <span class="hljs-keyword">int</span> n = nums[<span class="hljs-number">0</span>], prev = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums) &#123;
            <span class="hljs-keyword">if</span> (num == n) &#123;
                cnt++;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == n+<span class="hljs-number">1</span>) &#123;
                prev = cnt;
                n = num;
                cnt = <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                prev = <span class="hljs-number">0</span>;
                n = num;
                cnt = <span class="hljs-number">1</span>;
            &#125;
            
            <span class="hljs-keyword">if</span> (prev != <span class="hljs-number">0</span> &amp;&amp; cnt + prev &gt; max) &#123;
                max = cnt + prev;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> max;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="5-Simplify-Path"><a href="#5-Simplify-Path" class="headerlink" title="5. Simplify Path"></a>5. Simplify Path</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/simplify-path/">71. Simplify Path</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>将输入路径，改为绝对路径： <code>/</code> 开头，目录吉间用单个 <code>/</code> 分隔，除目录外不以 <code>/</code> 结尾，且不含 <code>.</code> 或<code>..</code> 目录</p>
<p><strong>题目解答：</strong></p>
<p>使用栈，以将相对路径转换为绝对路径。（ <code>.</code> 表示当前目录，<code>..</code> 表示上一层目录 ）</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">simplifyPath</span><span class="hljs-params">(String path)</span> </span>&#123;
        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        path += <span class="hljs-string">&quot;/&quot;</span>;
        
        <span class="hljs-keyword">int</span> prev = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; path.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (path.charAt(i) == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;
                <span class="hljs-keyword">if</span> (prev != -<span class="hljs-number">1</span>) &#123;
                    String s = path.substring(prev+<span class="hljs-number">1</span>, i);
                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;..&quot;</span>.equals(s)) &#123;
                        <span class="hljs-keyword">if</span> (!stack.empty()) stack.pop();
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;.&quot;</span>.equals(s) &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(s)) &#123;
                        stack.push(s);
                    &#125;   
                &#125;
                prev = i;
            &#125;
        &#125;
        
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span>(!stack.empty()) &#123;
            String s = stack.pop();
            sb.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;/&quot;</span> + s);
            
        &#125;
        <span class="hljs-keyword">return</span> sb.length() == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;/&quot;</span> : sb.toString();
    &#125;
&#125;</code></pre>
<br/>

<h2 id="6-Binary-Tree-Right-Side-View"><a href="#6-Binary-Tree-Right-Side-View" class="headerlink" title="6. Binary Tree Right Side View"></a>6. Binary Tree Right Side View</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给定二叉树，求在二叉树右侧所看到的一列值，即求二叉树每层最右侧值的组成的列表</p>
<p><strong>题目解答：</strong></p>
<p>最直接的做法是层序遍历，但写起来比较麻烦，需要判断当前在哪一层，因此直接用递归写了个解法。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for a binary tree node.</span>
<span class="hljs-comment"> * public class TreeNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     TreeNode left;</span>
<span class="hljs-comment"> *     TreeNode right;</span>
<span class="hljs-comment"> *     TreeNode() &#123;&#125;</span>
<span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span>
<span class="hljs-comment"> *         this.val = val;</span>
<span class="hljs-comment"> *         this.left = left;</span>
<span class="hljs-comment"> *         this.right = right;</span>
<span class="hljs-comment"> *     &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
        process(root, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> ret;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> layer)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (ret.size() &lt;= layer) ret.add(node.val);
        <span class="hljs-keyword">else</span> ret.set(layer, node.val);
        
        process(node.left, layer+<span class="hljs-number">1</span>);
        process(node.right, layer+<span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre>
<br/>

<h2 id="7-Shortest-Distance-to-a-Character"><a href="#7-Shortest-Distance-to-a-Character" class="headerlink" title="7. Shortest Distance to a Character"></a>7. Shortest Distance to a Character</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-distance-to-a-character/">821. Shortest Distance to a Character</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给定字符串和其中的一个字符，求字符串内每个位置与该字符的最短距离</p>
<p><strong>题目解答：</strong></p>
<p>找到该字符的每个位置，推算其周围的距离。</p>
<blockquote>
<p>注：这里将 ret[i] 初始化为 -1 可以优化为 <code>Integer.MAX_VALUE</code> 以免去 <code>ret[i] == -1</code> 的判断</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] shortestToChar(String s, <span class="hljs-keyword">char</span> c) &#123;
        <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            ret[i] = -<span class="hljs-number">1</span>;
        &#125;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (s.charAt(i) == c) &#123;
                checkDistance(s, i, c, ret);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkDistance</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span>[] ret)</span> </span>&#123;
        ret[i] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">boolean</span> lFin = <span class="hljs-keyword">false</span>, rFin = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = i-<span class="hljs-number">1</span>, r = i+<span class="hljs-number">1</span>; !lFin || !rFin; l--,r++) &#123;
            <span class="hljs-keyword">if</span> (!lFin)  &#123;
                <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span> || s.charAt(l) == c) &#123;
                    lFin = <span class="hljs-keyword">true</span>;
                &#125;
                <span class="hljs-keyword">if</span> (!lFin &amp;&amp; (ret[l] == -<span class="hljs-number">1</span> || ret[l] &gt; i-l)) &#123;
                    ret[l] = i-l;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    lFin = <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (!rFin) &#123;
                <span class="hljs-keyword">if</span> (r &gt;= s.length() || s.charAt(r) == c) &#123;
                    rFin = <span class="hljs-keyword">true</span>;
                &#125;
                <span class="hljs-keyword">if</span> (!rFin &amp;&amp; (ret[r] == -<span class="hljs-number">1</span> || ret[r] &gt; r-i)) &#123;
                    ret[r] = r-i;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    rFin = <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="8-Peeking-Iterator"><a href="#8-Peeking-Iterator" class="headerlink" title="8. Peeking Iterator"></a>8. Peeking Iterator</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/peeking-iterator/">284. Peeking Iterator</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给定一个 Iterator 对象，要求基于该对象包装，实现 peek() 方法，返回下一个元素，但不移动位置。</p>
<p><strong>题目解答：</strong></p>
<p>基于已有的 <code>next()</code> 和 <code>hasNext()</code> 显然不提供此功能，因此 peek 时实际上必然要发生移动，需要记录此时发生了 <code>peek</code> 操作，和当前 <code>peek</code> 的值用于后续操作。</p>
<pre><code class="hljs java"><span class="hljs-comment">// Java Iterator interface reference:</span>
<span class="hljs-comment">// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeekingIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> Iterator&lt;Integer&gt; iterator;
    <span class="hljs-keyword">private</span> Integer current = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPeek = <span class="hljs-keyword">false</span>;
    
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PeekingIterator</span><span class="hljs-params">(Iterator&lt;Integer&gt; iterator)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.iterator = iterator;
	    
	&#125;
	
    <span class="hljs-comment">// Returns the next element in the iteration without advancing the iterator.</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (isPeek) <span class="hljs-keyword">return</span> current;
        <span class="hljs-keyword">else</span> &#123;
            isPeek = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">return</span> current = iterator.next();
        &#125;
	&#125;
	
	<span class="hljs-comment">// hasNext() and next() should behave the same as in the Iterator interface.</span>
	<span class="hljs-comment">// Override them if needed.</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (isPeek) &#123;
            isPeek = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">return</span> current;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> iterator.next();
	&#125;
	
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
	    <span class="hljs-keyword">return</span> iterator.hasNext() || isPeek;
	&#125;
&#125;</code></pre>
<br/>

<h2 id="9-Convert-BST-to-Greater-Tree"><a href="#9-Convert-BST-to-Greater-Tree" class="headerlink" title="9. Convert BST to Greater Tree"></a>9. Convert BST to Greater Tree</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给定二叉搜索树，为每个节点的值增加大于该节点值的节点值之和。</p>
<p><strong>题目解答：</strong></p>
<p>基于二叉搜索树的特点，实际上每个节点值就是按照后续遍历时的累加和。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for a binary tree node.</span>
<span class="hljs-comment"> * public class TreeNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     TreeNode left;</span>
<span class="hljs-comment"> *     TreeNode right;</span>
<span class="hljs-comment"> *     TreeNode() &#123;&#125;</span>
<span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span>
<span class="hljs-comment"> *         this.val = val;</span>
<span class="hljs-comment"> *         this.left = left;</span>
<span class="hljs-comment"> *         this.right = right;</span>
<span class="hljs-comment"> *     &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        
        convertBST(root.right);
        sum += root.val;
        root.val = sum;
        convertBST(root.left);
        <span class="hljs-keyword">return</span> root;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="10-Copy-List-with-Random-Pointer"><a href="#10-Copy-List-with-Random-Pointer" class="headerlink" title="10. Copy List with Random Pointer"></a>10. Copy List with Random Pointer</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/copy-list-with-random-pointer/">138. Copy List with Random Pointer</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个列表，next 值指向下一节点，random 值指向某一结点，要求深拷贝该列表。（注意原链表不能修改，且新链表必须均为全新节点）</p>
<p><strong>题目解答：</strong></p>
<p>这道题的主要问题是新旧节点的映射关系问题，一个旧节点必须对应唯一的新节点。上次做这道题直接用 Map 记录了映射关系，本次则采用了在链表内增加元素的方式（A –&gt; A’ –&gt; B –&gt; B’ –&gt; C –&gt; C’ –&gt; D –&gt; D’，带 <code>&#39;</code> 的为新节点），以节约空间占用，旧节点的下一位置即新节点。</p>
<blockquote>
<p>最终需要拆分为两个链表，注意原链表的位置关系也需要修复</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">// Definition for a Node.</span>
<span class="hljs-comment">class Node &#123;</span>
<span class="hljs-comment">    int val;</span>
<span class="hljs-comment">    Node next;</span>
<span class="hljs-comment">    Node random;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    public Node(int val) &#123;</span>
<span class="hljs-comment">        this.val = val;</span>
<span class="hljs-comment">        this.next = null;</span>
<span class="hljs-comment">        this.random = null;</span>
<span class="hljs-comment">    &#125;</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        
        Node node = head;
        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;
            Node nextNode = node.next;
            node.next = <span class="hljs-keyword">new</span> Node(node.val);
            node.next.next = nextNode;
            node = nextNode;
        &#125;
        
        node = head;
        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;
            node.next.random = node.random == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : node.random.next;
            node = node.next.next;
        &#125;
        
        node = head;
        Node ret = head.next;
        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;
            Node nextNode = node.next;
            node.next = node.next == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : node.next.next;
            node = nextNode;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="11-Valid-Anagram"><a href="#11-Valid-Anagram" class="headerlink" title="11. Valid Anagram"></a>11. Valid Anagram</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-anagram/">242. Valid Anagram</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>验证给出的两个字符串是否为有效的字谜（即字符仅允许顺序不同）</p>
<p><strong>题目解答：</strong></p>
<p>这里直接重排序判断，还可以用类似计数排序（<code>char[26]</code>）的方式比较。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;
        <span class="hljs-keyword">char</span>[] a = s.toCharArray(), b = t.toCharArray();
        Arrays.sort(a);
        Arrays.sort(b);
        <span class="hljs-keyword">return</span> Arrays.equals(a, b);
    &#125;
&#125;</code></pre>
<br/>

<h2 id="12-Number-of-Steps-to-Reduce-a-Number-to-Zero"><a href="#12-Number-of-Steps-to-Reduce-a-Number-to-Zero" class="headerlink" title="12. Number of Steps to Reduce a Number to Zero"></a>12. Number of Steps to Reduce a Number to Zero</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/">1342. Number of Steps to Reduce a Number to Zero</a>  <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个整数，按 “偶数时除二，奇数时减一” 的规则，求多少次运算后值变为 0</p>
<p><strong>题目解答：</strong></p>
<p>根据递推公式，写个递归</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfSteps</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>) &#123;
            num = num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? num/<span class="hljs-number">2</span> : num-<span class="hljs-number">1</span>;
            cnt++;
        &#125;
        <span class="hljs-keyword">return</span> cnt;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="13-Shortest-Path-in-Binary-Matrix"><a href="#13-Shortest-Path-in-Binary-Matrix" class="headerlink" title="13. Shortest Path in Binary Matrix"></a>13. Shortest Path in Binary Matrix</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. Shortest Path in Binary Matrix</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个正方形数组，0 代表可以通过，1 代表道路不通，求从左上角到右下角的最少需要经过的格子数，每次行动可移动到周围八个格子内。</p>
<p><strong>题目解答：</strong></p>
<p>宽度优先搜索，结合优先队列。如果找到了已知节点的更优解则重新计算相关节点。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] gotos = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;
        <span class="hljs-keyword">int</span> N = grid.length;
        <span class="hljs-keyword">int</span>[][] shortestPaths = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][N];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;
                shortestPaths[i][j] = Integer.MAX_VALUE;
            &#125;
        &#125;

        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr1[<span class="hljs-number">2</span>] - arr2[<span class="hljs-number">2</span>]);
        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;
            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);
        &#125;
        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;
            <span class="hljs-keyword">int</span>[] arr = queue.poll();
            <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">2</span>] &gt;= shortestPaths[arr[<span class="hljs-number">0</span>]][arr[<span class="hljs-number">1</span>]]) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            shortestPaths[arr[<span class="hljs-number">0</span>]][arr[<span class="hljs-number">1</span>]] = arr[<span class="hljs-number">2</span>];
            <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] == N-<span class="hljs-number">1</span> &amp;&amp; arr[<span class="hljs-number">1</span>] == N-<span class="hljs-number">1</span>) &#123;
                <span class="hljs-keyword">return</span> arr[<span class="hljs-number">2</span>];
            &#125;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gotos.length; i++) &#123;
                <span class="hljs-keyword">int</span> nextX = arr[<span class="hljs-number">0</span>] + gotos[i][<span class="hljs-number">0</span>], nextY = arr[<span class="hljs-number">1</span>] + gotos[i][<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (nextX &lt; <span class="hljs-number">0</span> || nextX &gt;= N || nextY &lt; <span class="hljs-number">0</span> || nextY &gt;= N || grid[nextX][nextY] == <span class="hljs-number">1</span>) &#123;
                    <span class="hljs-keyword">continue</span>;
                &#125;
                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nextX, nextY, arr[<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>&#125;);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>
<br/>


<h2 id="14-Is-Graph-Bipartite"><a href="#14-Is-Graph-Bipartite" class="headerlink" title="14. Is Graph Bipartite?"></a>14. Is Graph Bipartite?</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-graph-bipartite/">785. Is Graph Bipartite?</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个图形，判断该图形的节点是否可以分为两个集合，使得任意一条边的端点都分别位于两个集合内。（不保证所有点都连接，不保证图形连续）</p>
<p><strong>题目解答：</strong></p>
<p>假设节点 A 位于集合 1，则节点 A 连接的节点必位于集合 2，持续判断（宽度优先搜索，这里使用递归）直到发现冲突。注意，每个符合条件的节点都需检查。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;
        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[graph.length];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.length; i++) &#123;
            arr[i] = -<span class="hljs-number">1</span>;
        &#125;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.length; i++) &#123;
            <span class="hljs-keyword">if</span> (graph[i].length != <span class="hljs-number">0</span> &amp;&amp; arr[i] == -<span class="hljs-number">1</span> &amp;&amp; !check(graph, i, <span class="hljs-number">1</span>)) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> group)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (arr[i] == -<span class="hljs-number">1</span>) &#123;
            arr[i] = group;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> arr[i] == group;
        &#125;
        
        <span class="hljs-keyword">int</span> nextGroup = group == <span class="hljs-number">1</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; graph[i].length; j++) &#123;
            <span class="hljs-keyword">if</span> (!check(graph, graph[i][j], nextGroup)) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="15-The-K-Weakest-Rows-in-a-Matrix"><a href="#15-The-K-Weakest-Rows-in-a-Matrix" class="headerlink" title="15. The K Weakest Rows in a Matrix"></a>15. The K Weakest Rows in a Matrix</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/">1337. The K Weakest Rows in a Matrix</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个由 0、1 构成的二维矩阵，要求按照 1 的数量从小到大排序每行，数量相等时按原始行号（0 起始）顺序排序，求排序后前 k 行的行号。</p>
<p><strong>题目解答：</strong></p>
<p>自定义排序即可</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] kWeakestRows(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> k) &#123;
        List&lt;Pair&lt;Integer, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;
            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat[i].length; j++) &#123;
                cnt += mat[i][j];
            &#125;
            list.add(<span class="hljs-keyword">new</span> Pair(cnt, i));
        &#125;

        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Pair&lt;Integer, Integer&gt;&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Pair&lt;Integer, Integer&gt; a, Pair&lt;Integer, Integer&gt; b)</span> </span>&#123;
                <span class="hljs-keyword">return</span> a.getKey() != b.getKey() ? a.getKey()-b.getKey() : a.getValue() - b.getValue();
            &#125;
        &#125;);
        
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
        <span class="hljs-keyword">for</span>(Pair&lt;Integer, Integer&gt; p : list) &#123;
            ret[i++] = p.getValue();
            <span class="hljs-keyword">if</span> (i &gt;= k) <span class="hljs-keyword">return</span> ret;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="16-Letter-Case-Permutation"><a href="#16-Letter-Case-Permutation" class="headerlink" title="16. Letter Case Permutation"></a>16. Letter Case Permutation</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-case-permutation/">784. Letter Case Permutation</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出原始字符串，其中的英文字母可转换为大写或小写字母，求所有可能生成的字符串。（不要求返回值顺序）</p>
<p><strong>题目解答：</strong></p>
<p>递归遍历每个位置的所有可能值</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(String S)</span> </span>&#123;
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        process(S.toLowerCase(), <span class="hljs-number">0</span>, list, <span class="hljs-keyword">new</span> StringBuilder());
        <span class="hljs-keyword">return</span> list;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i, List&lt;String&gt; list, StringBuilder sb)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (sb.length() == s.length()) &#123;
            list.add(sb.toString());
            <span class="hljs-keyword">return</span> ;
        &#125;
        <span class="hljs-keyword">char</span> c = s.charAt(i);
        <span class="hljs-keyword">char</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>;
        
        arr[<span class="hljs-number">0</span>] = c;
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;
            arr[l++] = (<span class="hljs-keyword">char</span>) ((<span class="hljs-keyword">int</span>)c-<span class="hljs-number">32</span>);
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; l; j++) &#123;
            sb.append(arr[j]);
            process(s, i+<span class="hljs-number">1</span>, list, sb);
            sb.delete(sb.length()-<span class="hljs-number">1</span>, sb.length());
        &#125;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="17-Container-With-Most-Water"><a href="#17-Container-With-Most-Water" class="headerlink" title="17. Container With Most Water"></a>17. Container With Most Water</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a> ``</p>
<p><strong>题目简述：</strong></p>
<p>给出 n 个非负整数，代表相互距离为 1 的垂直边高度。找到最合适的两个边，使之与 x 轴所形成的容器能够承载最多的水。</p>
<p><strong>题目解答：</strong></p>
<p>双指针扫描，任意两条边所能承载的水量为 最小垂直高度 * 距离。本题将指针分别位于最左和最右端，使之距离最长，然后逐步尝试提高最小高度，以谋求最优解。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>, ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(l &lt; r) &#123;
            <span class="hljs-keyword">int</span> w = r-l, h = Math.min(height[l], height[r]);
            <span class="hljs-keyword">if</span> (w*h &gt; ret) &#123;
                ret = w*h;
            &#125;
            
            <span class="hljs-keyword">if</span> (height[l] == h) &#123;
                <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; height[l] &lt;= h) &#123;
                    l++;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (height[r] == h) &#123;
                <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; height[r] &lt;= h) &#123;
                    r--;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="18-Arithmetic-Slices"><a href="#18-Arithmetic-Slices" class="headerlink" title="18. Arithmetic Slices"></a>18. Arithmetic Slices</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/arithmetic-slices/">413. Arithmetic Slices</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>（待补充）</p>
<p><strong>题目解答：</strong></p>
<p>（待补充）</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; dp.length; i++) &#123;
            <span class="hljs-keyword">if</span> (A[i] - A[i-<span class="hljs-number">1</span>] == A[i-<span class="hljs-number">1</span>] - A[i-<span class="hljs-number">2</span>]) &#123;
                dp[i] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
                sum += dp[i];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="19-Minimum-Remove-to-Make-Valid-Parentheses"><a href="#19-Minimum-Remove-to-Make-Valid-Parentheses" class="headerlink" title="19. Minimum Remove to Make Valid Parentheses"></a>19. Minimum Remove to Make Valid Parentheses</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/">1249. Minimum Remove to Make Valid Parentheses</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出小写字母与括号构成的字符串，要求从中移除最少数量的字符，以生成有效的括号表达式，即括号成对的字符串。（返回任一种有效表达式即可）</p>
<p><strong>题目解答：</strong></p>
<p>直观的做法是对左括号建立栈，此处用 <code>list</code> 模拟栈，寻找到多余的括号后则移除相关符号。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minRemoveToMakeValid</span><span class="hljs-params">(String s)</span> </span>&#123;
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;
            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;
                cnt++;
                sb.append(c);
                list.add(sb.length()-<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;
                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;
                    cnt--;
                    list.remove(list.size()-<span class="hljs-number">1</span>);
                    sb.append(c);
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                sb.append(c);
            &#125;
        &#125;
        
        <span class="hljs-keyword">if</span> (cnt != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = list.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
                sb.delete(list.get(i), list.get(i)+<span class="hljs-number">1</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> sb.toString();
    &#125;
&#125;</code></pre>
<br/>


<h2 id="20-Roman-to-Integer"><a href="#20-Roman-to-Integer" class="headerlink" title="20. Roman to Integer"></a>20. Roman to Integer</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/">13. Roman to Integer</a> <code>Easy   </code></p>
<p><strong>题目简述：</strong></p>
<p>将罗马数字字符串转换为数字。（字符串范围：<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code>, <code>M</code>）</p>
<p><strong>题目解答：</strong></p>
<p>遍历各个字符即可，注意某些组合时，需要将两个字符放在一起运算。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span> &lt; s.length() &amp;&amp; match(s.charAt(i), s.charAt(i+<span class="hljs-number">1</span>))) &#123;
                ret += romanToInt(s.charAt(i+<span class="hljs-number">1</span>)) - romanToInt(s.charAt(i));
                i++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                ret += romanToInt(s.charAt(i));
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;
        <span class="hljs-keyword">switch</span>(c) &#123;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">500</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;
            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b)</span> </span>&#123;
        <span class="hljs-keyword">return</span> (a == <span class="hljs-string">&#x27;I&#x27;</span> &amp;&amp; (b == <span class="hljs-string">&#x27;V&#x27;</span> || b == <span class="hljs-string">&#x27;X&#x27;</span>)) || 
            (a == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; (b == <span class="hljs-string">&#x27;L&#x27;</span> || b == <span class="hljs-string">&#x27;C&#x27;</span>)) || 
            (a == <span class="hljs-string">&#x27;C&#x27;</span> &amp;&amp; (b == <span class="hljs-string">&#x27;D&#x27;</span> || b == <span class="hljs-string">&#x27;M&#x27;</span>));
    &#125;
&#125;</code></pre>
<br/>

<h2 id="21-Broken-Calculator"><a href="#21-Broken-Calculator" class="headerlink" title="21. Broken Calculator"></a>21. Broken Calculator</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/broken-calculator/">991. Broken Calculator</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出数字 X，Y，每次可以对 X 执行 “乘二” 或 “减一” 操作，求最少多少次操作后 X 可以变为 Y。</p>
<p><strong>题目解答：</strong></p>
<p>当 X 比 Y 大时，必然需要执行 X-Y 次减一操作，反之，X 的操作可以转换为 Y 的反方向操作。</p>
<p><em>说明；根据规则，X 通过一定操作能得到 Y 则 Y 一定能反向得到 X。此时，如果 Y 是偶数，则说明上一步 X 做了乘二操作，同理奇数为减一操作</em></p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">brokenCalc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Y)</span> </span>&#123;
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (X &lt; Y) &#123;
            cnt++;
            <span class="hljs-keyword">if</span> (Y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;
                Y++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                Y /= <span class="hljs-number">2</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> X-Y+cnt;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="22-Longest-Word-in-Dictionary-through-Deleting"><a href="#22-Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="22. Longest Word in Dictionary through Deleting"></a>22. Longest Word in Dictionary through Deleting</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/">524. Longest Word in Dictionary through Deleting</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出字符串 <code>s</code> 和字典 <code>dictionary</code>，要求通过在字符串中删除任意字符，得到字典中的单词，返回最长的单词，相同长度时返回字典序最小的一个。</p>
<p><strong>题目解答：</strong></p>
<p>直接排序遍历解答。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; d)</span> </span>&#123;
        Collections.sort(d, (s1, s2) -&gt; s1.length()==s2.length() ? s1.compareTo(s2) : s2.length()-s1.length());
        <span class="hljs-keyword">for</span>(String dic : d) &#123;
            <span class="hljs-keyword">if</span> (isMatch(s, dic)) &#123;
                <span class="hljs-keyword">return</span> dic;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String d)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; d.length()) &#123;
            <span class="hljs-keyword">if</span> (s.charAt(i) == d.charAt(j)) &#123;
                j++;
            &#125;
            i++;
        &#125;
        <span class="hljs-keyword">return</span> j == d.length();
    &#125;
&#125;</code></pre>
<br/>

<h2 id="23-Search-a-2D-Matrix-II"><a href="#23-Search-a-2D-Matrix-II" class="headerlink" title="23. Search a 2D Matrix II"></a>23. Search a 2D Matrix II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix-ii/">240. Search a 2D Matrix II</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出二维矩阵，每行自左到右递增，每列自上到下递增。求矩阵内是否有某个值 <code>target</code>。</p>
<p><strong>题目解答：</strong></p>
<p>经典题目，从左下或右上开始查询即可。比如左下开始，小于目标值则右移，大于目标值则上移。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = matrix.length-<span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; matrix[<span class="hljs-number">0</span>].length) &#123;
            <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) &#123;
                i--;
            &#125; <span class="hljs-keyword">else</span> &#123;
                j++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="24-Score-of-Parentheses"><a href="#24-Score-of-Parentheses" class="headerlink" title="24. Score of Parentheses"></a>24. Score of Parentheses</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/score-of-parentheses/">856. Score of Parentheses</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出平衡的括号表达式（仅由 <code>(</code>，<code>)</code> 构成），计算其分值：</p>
<ol>
<li><code>()</code> 记一分</li>
<li>A、B 均为平衡括号表达式，则 <code>AB</code> 分值等于 A，B 表达式的分值之和</li>
<li>A 为平衡括号表达式，<code>(A)</code> 的分支等于 A 表达式的分值乘以二</li>
</ol>
<p><strong>题目解答：</strong></p>
<p>按规则逐步递归计分即可</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">scoreOfParentheses</span><span class="hljs-params">(String S)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(S)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;()&quot;</span>.equals(S)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        
        <span class="hljs-keyword">int</span> l = -<span class="hljs-number">1</span>, cnt = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (S.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;
                cnt++;
                <span class="hljs-keyword">if</span> (l == -<span class="hljs-number">1</span>) l = i;
            &#125;
            <span class="hljs-keyword">else</span> &#123;
                cnt--;
            &#125;
            
            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">int</span> score = scoreOfParentheses(S.substring(l+<span class="hljs-number">1</span>, i));
                ret += score == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : score * <span class="hljs-number">2</span>;
                l = -<span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="25-Shortest-Unsorted-Continuous-Subarray"><a href="#25-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="25. Shortest Unsorted Continuous Subarray"></a>25. Shortest Unsorted Continuous Subarray</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/">581. Shortest Unsorted Continuous Subarray</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出数组 <code>arr</code>，求最少需要对多长的连续子数组重排序，可以使整个数组有序？</p>
<p><strong>题目解答：</strong></p>
<p>这道题用了个野蛮的解法，直接排序后比对前后数组。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            arr[i] = nums[i];
        &#125;
        Arrays.sort(arr);
        
        <span class="hljs-keyword">int</span> ret = nums.length;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span> (arr[i] == nums[i]) &#123;
                ret--;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-keyword">if</span> (arr[i] == nums[i]) &#123;
                ret--;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : ret;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="26-Validate-Stack-Sequences"><a href="#26-Validate-Stack-Sequences" class="headerlink" title="26. Validate Stack Sequences"></a>26. Validate Stack Sequences</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-stack-sequences/">946. Validate Stack Sequences</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出入栈序列 <code>pushed</code> 与出栈序列 <code>popped</code>，判断对于一个空栈，是否可以通过出入栈实现此序列。（序列内所有值均唯一）</p>
<p><strong>题目解答：</strong></p>
<p>用一个栈尝试模拟解答即可</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = pushed.length, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        
        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        stack.push(pushed[i++]);
        <span class="hljs-keyword">while</span>(!stack.empty() || i &lt; n) &#123;
            <span class="hljs-comment">// 如果栈顶符合，出栈</span>
            <span class="hljs-keyword">if</span> (!stack.empty() &amp;&amp; stack.peek() == popped[j]) &#123;
                stack.pop();
                j++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// 所有数据均已入栈，仍不符合</span>
                <span class="hljs-keyword">if</span> (i &gt;= n) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                <span class="hljs-comment">// 数据继续入栈</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    stack.push(pushed[i++]);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="27-Divide-Two-Integers"><a href="#27-Divide-Two-Integers" class="headerlink" title="27. Divide Two Integers"></a>27. Divide Two Integers</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/">29. Divide Two Integers</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>不适用乘、除、取余操作，给出被除数 <code>dividend</code> 和除数 <code>divisor</code>（两个数均可能为负数），求两个数相除的整数商。（返回 <code>[−2^31,  2^31 − 1]</code> 范围内的值，超过则返回范围内最接近的值）</p>
<p><strong>题目解答：</strong></p>
<p>不适用乘、除、取余，则只能用最朴素的加法运算。但如果每次只加一格速度过慢，这里每次翻倍以尽快接近目标值。（2 进制思想）</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;
        <span class="hljs-keyword">int</span> flag = (dividend &gt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span> || dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> ret = div(Math.abs((<span class="hljs-keyword">long</span>) dividend), Math.abs((<span class="hljs-keyword">long</span>) divisor));
        
        <span class="hljs-keyword">if</span> (ret &gt; Integer.MAX_VALUE) <span class="hljs-keyword">return</span> flag == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) ret * flag;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">long</span> dividend, <span class="hljs-keyword">long</span> divisor)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (divisor &gt; dividend) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">long</span> mul = <span class="hljs-number">1</span>, sum = divisor;
        <span class="hljs-keyword">while</span>(sum + sum &lt; dividend) &#123;
            sum += sum;
            mul += mul;
        &#125;
        <span class="hljs-keyword">return</span> mul + div(dividend - sum, divisor);
    &#125;
&#125;</code></pre>
<br/>

<h2 id="28-Maximum-Frequency-Stack"><a href="#28-Maximum-Frequency-Stack" class="headerlink" title="28. Maximum Frequency Stack"></a>28. Maximum Frequency Stack</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-frequency-stack/">895. Maximum Frequency Stack</a> <code>Hard</code></p>
<p><strong>题目简述：</strong></p>
<p>实现 <code>FreqStack</code>，以使得 <code>push(int x)</code> 方法向栈内增加一个值，<code>pop()</code> 移除并返回栈内出现次数最多的值，如果有个多个值满足，则返回最接近栈顶的值。</p>
<p><strong>题目解答：</strong></p>
<p>按照出现频次和位置排序各个值即可，这里用优先队列，自定义 <code>Comparator</code> 实现。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreqStack</span> </span>&#123;
    List&lt;Integer&gt; data = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    Map&lt;Integer, Integer&gt; cntMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    Queue&lt;Pair&lt;Integer, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">new</span> Comparator&lt;Pair&lt;Integer, Integer&gt;&gt;() &#123; 
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Pair&lt;Integer, Integer&gt; a, Pair&lt;Integer, Integer&gt; b)</span> </span>
<span class="hljs-function">        </span>&#123;
            <span class="hljs-keyword">if</span> (a.getKey().equals(b.getKey())) <span class="hljs-keyword">return</span> b.getValue().compareTo(a.getValue());
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b.getKey().compareTo(a.getKey());
        &#125;
    &#125;);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreqStack</span><span class="hljs-params">()</span> </span>&#123;
        
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
        <span class="hljs-keyword">int</span> place = data.size();
        data.add(x);
        
        Integer cnt = cntMap.getOrDefault(x, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>;
        cntMap.put(x, cnt);
        queue.offer(<span class="hljs-keyword">new</span> Pair&lt;Integer, Integer&gt;(cnt, place));
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!queue.isEmpty()) &#123;
            Pair&lt;Integer, Integer&gt; pair = queue.poll();
            <span class="hljs-keyword">int</span> x = data.get(pair.getValue());
            cntMap.put(x, cntMap.get(x)-<span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> x;
        &#125;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your FreqStack object will be instantiated and called as such:</span>
<span class="hljs-comment"> * FreqStack obj = new FreqStack();</span>
<span class="hljs-comment"> * obj.push(x);</span>
<span class="hljs-comment"> * int param_2 = obj.pop();</span>
<span class="hljs-comment"> */</span></code></pre>
<br/>

    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    </div>
    
    
    <script>
        hljs.initHighlightingOnLoad();
    </script>
</body>
</html>
