<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Not A Number</title>

    
    
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/github-markdown.css">

    
    
<link rel="stylesheet" href="/css/hlj/stackoverflow-light.css">

    
<script src="/js/highlight.pack.js"></script>

<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="sidebar">
    <div class="sidebar-title">
        <!--img src="/images/logo@2x.png" style="width:127px;"-->
        <a href="https://nxy006.github.io"><h1>Not A Number</h1></a>
    </div>
    
    <div class="sidebar-menu">
        <div><a href="/archives">归档</a></div>
    </div>
    
    <div class="sidebar-footer">
        <!-- <iframe 
            frameborder="0"
            border="1"
            marginwidth="0"
            marginheight="0"            
            width=280
            height=100
            src="//music.163.com/outchain/player?type=2&id=464916877&auto=true&height=60">
        </iframe> -->
        <div class="sidebar-background">Background: <a href="https://pixabay.com/zh/photos/snow-ice-winter-cold-snowy-nature-5852352" target="_blank">雪 冰 冬天</a></div>
        <div class="sidebar-licenses">Licenses: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC 4.0</a>
            <span class="cc-license-icons">
                <span id="cc-logo" class="icon"><img width="15px" alt="cc logo" src="https://creativecommons.org/images/deed/cc_icon_white_x2.png"></span>
                <span id="cc-attribution" class="icon"><img width="15px" src="https://creativecommons.org/images/deed/attribution_icon_white_x2.png"></span>
                <span id="cc-icon-nc" class="icon"><img width="15px" src="https://creativecommons.org/images/deed/nc_white_x2.png"></span>
                <span id="cc-icon-sa" class="icon"><img width="15px" src="https://creativecommons.org/images/deed/sa_white_x2.png"></span>
            </span>
        </div>
        <hr/>
        <div>©2021. All rights reserved.</div>
        <div>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>, custom theme</div>
    </div>
</div>
    <div class="content">
        

<div class="article">
    <div class="title"><a href="/2021/04/01/april-leetcoding-challenge-2021/">April LeetCoding Challenge 2021 解题报告</a></div>
    <div class="time">创建时间：2021-04-01 / 更新时间：2021-07-05</div>
    <div class="article-toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Palindrome-Linked-List"><span class="toc-text">1. Palindrome Linked List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Ones-and-Zeroes"><span class="toc-text">2. Ones and Zeroes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Longest-Valid-Parentheses"><span class="toc-text">3. Longest Valid Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Design-Circular-Queue"><span class="toc-text">4. Design Circular Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Global-and-Local-Inversions"><span class="toc-text">5. Global and Local Inversions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Minimum-Operations-to-Make-Array-Equal"><span class="toc-text">6. Minimum Operations to Make Array Equal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Determine-if-String-Halves-Are-Alike"><span class="toc-text">7. Determine if String Halves Are Alike</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Letter-Combinations-of-a-Phone-Number"><span class="toc-text">8. Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Verifying-an-Alien-Dictionary"><span class="toc-text">9. Verifying an Alien Dictionary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Longest-Increasing-Path-in-a-Matrix"><span class="toc-text">10. Longest Increasing Path in a Matrix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Deepest-Leaves-Sum"><span class="toc-text">11. Deepest Leaves Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Beautiful-Arrangement-II"><span class="toc-text">12. Beautiful Arrangement II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Flatten-Nested-List-Iterator"><span class="toc-text">13. Flatten Nested List Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Partition-List"><span class="toc-text">14. Partition List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Fibonacci-Number"><span class="toc-text">15. Fibonacci Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Remove-All-Adjacent-Duplicates-in-String-II"><span class="toc-text">16. Remove All Adjacent Duplicates in String II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Number-of-Submatrices-That-Sum-to-Target"><span class="toc-text">17. Number of Submatrices That Sum to Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Remove-Nth-Node-From-End-of-List"><span class="toc-text">18. Remove Nth Node From End of List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Combination-Sum-IV"><span class="toc-text">19. Combination Sum IV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-N-ary-Tree-Preorder-Traversal"><span class="toc-text">20. N-ary Tree Preorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Triangle"><span class="toc-text">21. Triangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Brick-Wall"><span class="toc-text">22. Brick Wall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Count-Binary-Substrings"><span class="toc-text">23. Count Binary Substrings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Critical-Connections-in-a-Network"><span class="toc-text">24. Critical Connections in a Network</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Rotate-Image"><span class="toc-text">25. Rotate Image</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Furthest-Building-You-Can-Reach"><span class="toc-text">26. Furthest Building You Can Reach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Power-of-Three"><span class="toc-text">27. Power of Three</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Unique-Paths-II"><span class="toc-text">28. Unique Paths II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="toc-text">29. Find First and Last Position of Element in Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-Powerful-Integers"><span class="toc-text">30. Powerful Integers</span></a></li></ol>
    </div>
    
        <div class="alert-warning alert-with-desc">
    <span class="alert-message">
        本文还处于 <b>草稿</b> 状态
    </span>
    <span class="alert-desc">
        草稿状态的文章尚未完成，可能有尚未核实或补充的内容，其内容的准确性无法保证
    </span>
</div>
    
    <div class="article-content markdown-body">
        <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/explore/featured/card/april-leetcoding-challenge-2021/">April LeetCoding Challenge 2021</a></p>
<p><strong>Week 1: April 1st - April 7th</strong></p>
<ol>
<li>Largest Unique Number <code>Premium</code></li>
<li><a href="#1-Palindrome-Linked-List">Palindrome Linked List</a></li>
<li><a href="#2-Ones-and-Zeroes">Ones and Zeroes</a></li>
<li><a href="#3-Longest-Valid-Parentheses">Longest Valid Parentheses</a></li>
<li><a href="#4-Design-Circular-Queue">Design Circular Queue</a></li>
<li><a href="#5-Global-and-Local-Inversions">Global and Local Inversions</a></li>
<li><a href="#6-Minimum-Operations-to-Make-Array-Equal">Minimum Operations to Make Array Equal</a></li>
<li><a href="#7-Determine-if-String-Halves-Are-Alike">Determine if String Halves Are Alike</a></li>
</ol>
<p><strong>Week 2: April 8th - April 14th</strong></p>
<ol>
<li>Inorder Successor in BST <code>Premium</code></li>
<li><a href="#8-Letter-Combinations-of-a-Phone-Number">Letter Combinations of a Phone Number</a></li>
<li><a href="#9-Verifying-an-Alien-Dictionary">Verifying an Alien Dictionary</a></li>
<li><a href="#10-Longest-Increasing-Path-in-a-Matrix">Longest Increasing Path in a Matrix</a></li>
<li><a href="#11-Deepest-Leaves-Sum">Deepest Leaves Sum</a></li>
<li><a href="#12-Beautiful-Arrangement-II">Beautiful Arrangement II</a></li>
<li><a href="#13-Flatten-Nested-List-Iterator">Flatten Nested List Iterator</a></li>
<li><a href="#14-Partition-List">Partition List</a></li>
</ol>
<p><strong>Week 3: April 15th - April 21st</strong></p>
<ol>
<li>Minimum Swaps to Group All 1’s Together <code>Premium</code></li>
<li><a href="#15-Fibonacci-Number">Fibonacci Number</a></li>
<li><a href="#16-Remove-All-Adjacent-Duplicates-in-String-II">Remove All Adjacent Duplicates in String II</a></li>
<li><a href="#17-Number-of-Submatrices-That-Sum-to-Target">Number of Submatrices That Sum to Target</a></li>
<li><a href="#18-Remove-Nth-Node-From-End-of-List">Remove Nth Node From End of List</a></li>
<li><a href="#19-Combination-Sum-IV">Combination Sum IV</a></li>
<li><a href="#20-N-ary-Tree-Preorder-Traversal">N-ary Tree Preorder Traversal</a></li>
<li><a href="#21-Triangle">Triangle</a></li>
</ol>
<p><strong>Week 4: April 22nd - April 28th</strong></p>
<ol>
<li>Missing Number In Arithmetic Progression <code>Premium</code></li>
<li><a href="#22-Brick-Wall">Brick Wall</a></li>
<li><a href="#23-Count-Binary-Substrings">Count Binary Substrings</a></li>
<li>Critical Connections in a Network</li>
<li><a href="#25-Rotate-Image">Rotate Image</a></li>
<li>Furthest Building You Can Reach</li>
<li><a href="#27-Power-of-Three">Power of Three</a></li>
<li><a href="#28-Unique-Paths-II">Unique Paths II</a></li>
</ol>
<p><strong>Week 5: April 29th - April 30th</strong></p>
<ol>
<li>Meeting Scheduler <code>Premium</code></li>
<li><a href="#29-Find-First-and-Last-Position-of-Element-in-Sorted-Array">Find First and Last Position of Element in Sorted Array</a></li>
<li><a href="#30-Powerful-Integers">Powerful Integers</a></li>
</ol>
<br/>

<h2 id="1-Palindrome-Linked-List"><a href="#1-Palindrome-Linked-List" class="headerlink" title="1. Palindrome Linked List"></a>1. Palindrome Linked List</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/">234. Palindrome Linked List</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>判断给出的链表是否是回文链表。</p>
<p><strong>提高：</strong> 能否用 O(n) 时间复杂度与 O(1) 空间复杂度完成？</p>
<p><strong>题目解答：</strong></p>
<p><strong>双指针（快慢指针）</strong>：提高要求其实是个很明显的提示，O(1) 空间复杂度下又要能保留反向结果，只能利用原链表，将右半边做反转即得到反向顺序，因而常量空间为分别代表正向和反向的指针位置。</p>
<p>时间复杂度： $O(n)$ ，空间复杂度： $O(1)$</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * public class ListNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     ListNode next;</span>
<span class="hljs-comment"> *     ListNode() &#123;&#125;</span>
<span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;
        ListNode ret = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
        ret.next = head;

        <span class="hljs-comment">// 左指针每次移动一位，右指针移动两位（如果右指针已经在结尾，左指针不再移动）</span>
        ListNode l = ret, r = ret;
        <span class="hljs-keyword">while</span>(r != <span class="hljs-keyword">null</span>) &#123;
            r = r.next;
            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;
                r = r.next;
                l = l.next;
            &#125;

        &#125;

        <span class="hljs-comment">// 左指针指向中间位置，下一个位置就是右半边的末尾，反转链表</span>
        ListNode last = revese(l.next);
        l.next = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 比较原链表与反转后链表</span>
        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; last != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (head.val != last.val) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            head = head.next;
            last = last.next;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-comment">// 反转链表</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">revese</span><span class="hljs-params">(ListNode head)</span> </span>&#123;
        ListNode prev = <span class="hljs-keyword">null</span>, node = head;
        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>) &#123;
            ListNode temp = node.next;
            node.next = prev;
            prev = node;
            node = temp;
        &#125;
        <span class="hljs-keyword">return</span> prev;
    &#125;
&#125;</code></pre>
<br/>


<h2 id="2-Ones-and-Zeroes"><a href="#2-Ones-and-Zeroes" class="headerlink" title="2. Ones and Zeroes"></a>2. Ones and Zeroes</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ones-and-zeroes/">474. Ones and Zeroes</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出二进制字符串 <code>strs</code>（字符串只包含 0，1）集合和整数 <code>m</code>、<code>n</code>，求 <code>strs</code> 的最大子集长度，要求子集所有字符最多包含 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 字符。</p>
<p><strong>题目解答：</strong></p>
<p>动态规划，dp[i][j] 表示用 i 个零和 j 个一限制时的最大子集长度。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span>(String str : strs) &#123;
            <span class="hljs-keyword">int</span> zeros = countZeroOfStr(str), ones = str.length() - zeros;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &gt;= zeros; i--) &#123;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &gt;= ones; j--) &#123;
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + <span class="hljs-number">1</span>);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[m][n];
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countZeroOfStr</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;
            cnt += c == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> cnt;
    &#125;
&#125;</code></pre>
<br/>


<h2 id="3-Longest-Valid-Parentheses"><a href="#3-Longest-Valid-Parentheses" class="headerlink" title="3. Longest Valid Parentheses"></a>3. Longest Valid Parentheses</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a> <code>Hard</code></p>
<p><strong>题目简述：</strong></p>
<p>给定由 <code>(</code>, <code>)</code> 构成的字符串，求其最长有效连续子字符串。（左右括号相互匹配的字符串称为有效字符串）</p>
<p><strong>题目解答：</strong></p>
<p>使用栈结构记录匹配位置</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">int</span> maxans = <span class="hljs-number">0</span>;
        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        stack.push(-<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;
                stack.push(i);
            &#125; <span class="hljs-keyword">else</span> &#123;
                stack.pop();
                <span class="hljs-keyword">if</span> (stack.empty()) &#123;
                    stack.push(i);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    maxans = Math.max(maxans, i - stack.peek());
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> maxans;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="4-Design-Circular-Queue"><a href="#4-Design-Circular-Queue" class="headerlink" title="4. Design Circular Queue"></a>4. Design Circular Queue</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-circular-queue/">622. Design Circular Queue</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>设计一个循环队列实现。 循环队列是一种线性数据结构，其操作遵循先进先出且队尾队首相连。该队列需要支持如下操作：</p>
<ul>
<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>
<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>
<li><code>isFull()</code>: 检查循环队列是否已满。</li>
</ul>
<p><strong>题目解答：</strong></p>
<p>使用数组记录元素值，并注意两个指针相对关系即可。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span> </span>&#123;
    <span class="hljs-keyword">int</span>[] arrayQueue = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> rear = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">boolean</span> noEl;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;
            arrayQueue  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
        <span class="hljs-keyword">this</span>.noEl = <span class="hljs-keyword">true</span>;
        
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.isFull())&#123;
            <span class="hljs-keyword">this</span>.noEl = <span class="hljs-keyword">false</span>;
            arrayQueue[rear] = value;
            rear++;
            rear = rear%arrayQueue.length;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        &#125; <span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.isEmpty())&#123;
            front++;
            front = front% arrayQueue.length;
            <span class="hljs-keyword">if</span>(front == rear)&#123;
                <span class="hljs-keyword">this</span>.noEl = <span class="hljs-keyword">true</span>;
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                
        &#125; <span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.isEmpty())&#123;
            <span class="hljs-keyword">return</span> arrayQueue[front];
        &#125; <span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;
            
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.isEmpty())&#123;
            <span class="hljs-keyword">if</span>(rear==<span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> arrayQueue[arrayQueue.length-<span class="hljs-number">1</span>];
            &#125; <span class="hljs-keyword">else</span>&#123;
             <span class="hljs-keyword">return</span> arrayQueue[rear-<span class="hljs-number">1</span>];
            &#125;
        &#125; <span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        &#125;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.noEl;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (rear == front)  &amp;&amp; !<span class="hljs-keyword">this</span>.noEl;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your MyCircularQueue object will be instantiated and called as such:</span>
<span class="hljs-comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span>
<span class="hljs-comment"> * boolean param_1 = obj.enQueue(value);</span>
<span class="hljs-comment"> * boolean param_2 = obj.deQueue();</span>
<span class="hljs-comment"> * int param_3 = obj.Front();</span>
<span class="hljs-comment"> * int param_4 = obj.Rear();</span>
<span class="hljs-comment"> * boolean param_5 = obj.isEmpty();</span>
<span class="hljs-comment"> * boolean param_6 = obj.isFull();</span>
<span class="hljs-comment"> */</span></code></pre>
<br/>



<h2 id="5-Global-and-Local-Inversions"><a href="#5-Global-and-Local-Inversions" class="headerlink" title="5. Global and Local Inversions"></a>5. Global and Local Inversions</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/global-and-local-inversions/">775. Global and Local Inversions</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个由 [0, n - 1] 内所有整数构成的的整数数组 nums，求该数组中 <em>“全局倒置”</em> 的数量是否等于 <em>“局部倒置”</em> 的数量。</p>
<p><em>“全局倒置”</em> 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; n</code></li>
<li><code>nums[i] &gt; nums[j]</code></li>
</ul>
<p><em>“局部倒置”</em> 的数目等于满足下述条件的下标 i 的数目：</p>
<ul>
<li><code>0 &lt;= i &lt; n - 1</code></li>
<li><code>nums[i] &gt; nums[i + 1]</code></li>
</ul>
<p><strong>题目解答：</strong></p>
<p>根据题目定义，局部倒置是全局导致的一种特殊情况，因而判断全局倒置的数量是否等于局部倒置的数量，相当于判断数组中是否存在非局部倒置。</p>
<p>思考以下情况：  </p>
<blockquote>
<p>对于不存在存在非局部倒置的排列而言，0 应该在哪里呢？ 如果 0 的下标大于等于 2，一定会有 A[0] &gt; A[2] = 0，这是一个非局部倒置。所以 0 只能出现在下标 0 或者下标 1。当 A[1] = 0，显然 A[0] = 1，否则就会有 A[0] &gt; A[j] = 1，这也是一个非局部倒置。当 A[0] = 0，这时候问题就转化成了一个子问题。</p>
<p>（LeetCode-CN 官方解释）</p>
</blockquote>
<p>可以归纳出不存在存在非局部倒置的数组的充分必要条件为 Math.abs(A[i] - i) &lt;= 1。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIdealPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)
            <span class="hljs-keyword">if</span> (i - A[i] &gt; <span class="hljs-number">1</span> || i - A[i] &lt; -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="6-Minimum-Operations-to-Make-Array-Equal"><a href="#6-Minimum-Operations-to-Make-Array-Equal" class="headerlink" title="6. Minimum Operations to Make Array Equal"></a>6. Minimum Operations to Make Array Equal</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-operations-to-make-array-equal/">1551. Minimum Operations to Make Array Equal</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>现有长度为 n 的数组，其取值为 <code>arr[i] = (2 * i) + 1</code>，现可以操作数组内元素，一次操作可以使得任意元素加一，且同时另一元素减一，求最少需要多少次操作可以使得数组内所有值相等。（题目保证一定能在有限步骤内完成）</p>
<p><strong>题目解答：</strong></p>
<p>题目中要求的数组，显然是 (1,3,5,..) 格式，此时：</p>
<ul>
<li>对奇数长度而言，需要使得左半数量的元素（<code>k = n/2</code>）每次加 $(…,8,4,2)$，即等差数列求和 $Sn=n(a_1+a_n)/2$，此时 $n = k，, a_1 = 2,a_n = 2*k = n$，即可得到，$ans = (k * (2 + 2*k))/2 = k * (k + 1)$</li>
<li>对偶数长度而言，需要加的值实际是 $(…,5,3,1)$，即每个值都比奇数时少一，因而在奇数情况下减 <code>k</code> 即可。</li>
</ul>
<p>时间复杂度：$O(1)$，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">int</span> k = n/<span class="hljs-number">2</span>;
        <span class="hljs-keyword">return</span> k * (k+<span class="hljs-number">1</span>) - (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? k : <span class="hljs-number">0</span>);
    &#125;
&#125;</code></pre>
<br/>



<h2 id="7-Determine-if-String-Halves-Are-Alike"><a href="#7-Determine-if-String-Halves-Are-Alike" class="headerlink" title="7. Determine if String Halves Are Alike"></a>7. Determine if String Halves Are Alike</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/determine-if-string-halves-are-alike/">1704. Determine if String Halves Are Alike</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给出偶数长度的字符串，将其划分为等长的两个新字符串，判断这两个字符串中元音字母（<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;A&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;I&#39;</code>, <code>&#39;O&#39;</code>, <code>&#39;U&#39;</code>）的数量是否相等。</p>
<p><strong>题目解答：</strong></p>
<p>枚举检查即可</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">halvesAreAlike</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length()/<span class="hljs-number">2</span>; i++) &#123;
            cnt += isVowel(s.charAt(i)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s.length()/<span class="hljs-number">2</span>; i &lt; s.length(); i++) &#123;
            cnt -= isVowel(s.charAt(i)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> cnt == <span class="hljs-number">0</span>;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVowel</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;
        <span class="hljs-keyword">return</span> 
            c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span> || 
            c == <span class="hljs-string">&#x27;A&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span> || c == <span class="hljs-string">&#x27;I&#x27;</span> || c == <span class="hljs-string">&#x27;O&#x27;</span> || c == <span class="hljs-string">&#x27;U&#x27;</span>;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="8-Letter-Combinations-of-a-Phone-Number"><a href="#8-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="8. Letter Combinations of a Phone Number"></a>8. Letter Combinations of a Phone Number</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。数字到字母的映射如下（与电话按键相同）。</p>
<p>注意：1 不对应任何字母，答案可以按任意顺序返回。</p>
<p><img src="/images/leetcode/april-leetcoding-challenge-2021/200px-Telephone-keypad2.svg.png"></p>
<p><strong>题目解答：</strong></p>
<p>根据映射关系，穷举所有的解即可。</p>
<p>时间复杂度：$O(3^m \times 4^n)$，空间复杂度：$O(m+n)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> String[] btns = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;
    <span class="hljs-keyword">private</span> List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (digits == <span class="hljs-keyword">null</span> || digits.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;
        
        process(digits, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);
        <span class="hljs-keyword">return</span> ans;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(String digits, <span class="hljs-keyword">int</span> i, String current)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (digits.length() == i) &#123;
            ans.add(current);
            <span class="hljs-keyword">return</span> ;
        &#125;
        
        <span class="hljs-keyword">int</span> num = digits.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : btns[num].toCharArray()) &#123;
            process(digits, i+<span class="hljs-number">1</span>, current + c);
        &#125;
    &#125;
&#125;</code></pre>
<br/>


<h2 id="9-Verifying-an-Alien-Dictionary"><a href="#9-Verifying-an-Alien-Dictionary" class="headerlink" title="9. Verifying an Alien Dictionary"></a>9. Verifying an Alien Dictionary</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/verifying-an-alien-dictionary/">953. Verifying an Alien Dictionary</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>现有一种外星语言同样使用小写英文字母，但顺序不同。先给出该语言的字母排序，和一个词典列表，判断词典中词语的排序是否与字母排序相符合。</p>
<p><strong>题目解答：</strong></p>
<p>用 Map 记录每个字母的排序值，再遍历检查词典中单词顺序即可。</p>
<p>时间复杂度：$O(m)$，空间复杂度：$O(1)$，$m$ 表示词典内单词数量</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> </span>&#123;
        <span class="hljs-keyword">int</span> sorted[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">27</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; order.length(); i++) &#123;
            sorted[order.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;
        &#125;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length-<span class="hljs-number">1</span>; i++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; words[i].length(); j++) &#123;
                <span class="hljs-keyword">if</span> (j &gt;= words[i+<span class="hljs-number">1</span>].length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                
                <span class="hljs-keyword">if</span> (words[i].charAt(j) != words[i+<span class="hljs-number">1</span>].charAt(j)) &#123;
                    <span class="hljs-keyword">if</span> (sorted[words[i].charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; sorted[words[i+<span class="hljs-number">1</span>].charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="10-Longest-Increasing-Path-in-a-Matrix"><a href="#10-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="10. Longest Increasing Path in a Matrix"></a>10. Longest Increasing Path in a Matrix</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">329. Longest Increasing Path in a Matrix</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给出矩阵，求矩阵内严格升序序列最长长度，每次可以上、下、左、右移动一格。</p>
<p><strong>题目解答：</strong></p>
<p>深度优先遍历，递归查询并记忆每个位置开始的最大升序长度。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n, m, ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] walks = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;, visited;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;
        n = matrix.length;
        m = matrix[<span class="hljs-number">0</span>].length;
        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];

        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;
                ret = Integer.max(ret, path(matrix, i, j));
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (visited[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> visited[i][j];

        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] walk : walks) &#123;
            <span class="hljs-keyword">int</span> nextI = i + walk[<span class="hljs-number">0</span>], nextJ = j + walk[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (nextI &gt;= <span class="hljs-number">0</span> &amp;&amp; nextI &lt; n &amp;&amp; nextJ &gt;= <span class="hljs-number">0</span> &amp;&amp; nextJ &lt; m &amp;&amp; matrix[nextI][nextJ] &gt; matrix[i][j]) &#123;
                ret = Integer.max(ret, path(matrix, nextI, nextJ) + <span class="hljs-number">1</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> visited[i][j] = ret;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="11-Deepest-Leaves-Sum"><a href="#11-Deepest-Leaves-Sum" class="headerlink" title="11. Deepest Leaves Sum"></a>11. Deepest Leaves Sum</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/">1302. Deepest Leaves Sum</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一棵二叉树，求二叉树层数最深的节点之和</p>
<p><strong>题目解答：</strong></p>
<p>深度优先遍历两轮，第一轮确定最大深度，第二轮对该深度求和即可。</p>
<p>时间复杂度：$O(N)$，空间复杂度：$O(H)$，其中 $N$ 是树中的节点个数，$H$ 是树的高度（最大深度）。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for a binary tree node.</span>
<span class="hljs-comment"> * public class TreeNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     TreeNode left;</span>
<span class="hljs-comment"> *     TreeNode right;</span>
<span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deepestLeavesSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;TreeNode&gt;();
        list.add(root);
        
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, currentTier = <span class="hljs-number">1</span>, nextTier = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(i &lt; list.size()) &#123;
            <span class="hljs-keyword">if</span> (count &gt;= currentTier) &#123;
                currentTier = nextTier;
                count = <span class="hljs-number">0</span>;
                nextTier = <span class="hljs-number">0</span>;
            &#125;
            
            TreeNode node = list.get(i++);
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;
                list.add(node.left);
                nextTier++;
            &#125;
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;
                list.add(node.right);
                nextTier++;
            &#125;
            count++;
        &#125;
        
        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(currentTier != <span class="hljs-number">0</span>) &#123;
            ret += list.remove(list.size() - <span class="hljs-number">1</span>).val;
            currentTier--;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;
</code></pre>
<br/>



<h2 id="12-Beautiful-Arrangement-II"><a href="#12-Beautiful-Arrangement-II" class="headerlink" title="12. Beautiful Arrangement II"></a>12. Beautiful Arrangement II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/beautiful-arrangement-ii/">667. Beautiful Arrangement II</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>使用 <code>1</code> 到 <code>n</code> 共 <code>n</code> 个数字组成一个序列，使得两个相邻数字的绝对值之差共有 k 种值。（如果存在多个解答，只需返回任一有效解答即可）</p>
<p><strong>题目解答：</strong></p>
<p>（官解）分析可得：</p>
<ul>
<li>如果 k 为 1：则有效解答为 <code>[1, 2, 3, .., n]</code></li>
<li>如果 k 为 n-1，则有效解答为 <code>[1, n, 2, n-1, 3, n-2, ....]</code></li>
</ul>
<p>因此，我们可以将答案分为两个部分，一个部分下，数字以最大的波动展示，以谋求最多的不同差值，直到达到 k 为止，将剩下的差值均置为 1。</p>
<p>比如 n = 6, k = 3 时，我们先尽量具有更大的差值，即 <code>[1, 4, 2, 3]</code>，此时差值分别为 <code>3</code>，<code>2</code>，<code>1</code>，已达到 k 种情况，剩下的差值只需都用 <code>1</code> 补齐即可，方法是将 <code>[1, 2]</code> 补在列表前面，并将已有列表的值均加 2，得到 <code>[1, 2, 3, 6, 4, 5]</code></p>
<p>算法为，第 r 个（0-indexed）元素取值：</p>
<ul>
<li>r 小于 n-k 时：<code>nums[r] = i+1</code></li>
<li>r 大于 n-k 时，<code>nums[r] = (i%2 == 0) ? (n-k + i/2) : (n - i/2)</code> （i/1 取值为 <code>1, 1, 2, 2, 3, 3, ...</code>）</li>
</ul>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArray(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;
        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt; n-k; v++) &#123;
            ans[c++] = v;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;
            ans[c++] = (i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ? (n-k + i/<span class="hljs-number">2</span>) : (n - i/<span class="hljs-number">2</span>);
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="13-Flatten-Nested-List-Iterator"><a href="#13-Flatten-Nested-List-Iterator" class="headerlink" title="13. Flatten Nested List Iterator"></a>13. Flatten Nested List Iterator</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-nested-list-iterator/">341. Flatten Nested List Iterator</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>题目给出一个嵌套的整型列表，每个列表中的值或者为一个整数，或者是另一个列表。要求设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>
<p><strong>题目解答：</strong></p>
<p>标准做法是栈，但是实现时候发现有写复杂，强制转换为非嵌套列表完成。但实际上这种做法并不符合迭代器的定义。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * // This is the interface that allows for creating nested lists.</span>
<span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span>
<span class="hljs-comment"> * public interface NestedInteger &#123;</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *     // <span class="hljs-doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span>
<span class="hljs-comment"> *     public boolean isInteger();</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *     // <span class="hljs-doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span>
<span class="hljs-comment"> *     // Return null if this NestedInteger holds a nested list</span>
<span class="hljs-comment"> *     public Integer getInteger();</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *     // <span class="hljs-doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span>
<span class="hljs-comment"> *     // Return empty list if this NestedInteger holds a single integer</span>
<span class="hljs-comment"> *     public List&lt;NestedInteger&gt; getList();</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> List&lt;NestedInteger&gt; list;
    <span class="hljs-keyword">private</span> Iterator&lt;NestedInteger&gt; it;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NestedIterator</span><span class="hljs-params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        init(nestedList);
        <span class="hljs-keyword">this</span>.it = list.iterator();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;
        <span class="hljs-keyword">for</span>(NestedInteger nested : nestedList) &#123;
            <span class="hljs-keyword">if</span> (nested.isInteger()) &#123;
                list.add(nested);
            &#125; <span class="hljs-keyword">else</span> &#123;
                init(nested.getList());
            &#125;
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it.next().getInteger();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it.hasNext();
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your NestedIterator object will be instantiated and called as such:</span>
<span class="hljs-comment"> * NestedIterator i = new NestedIterator(nestedList);</span>
<span class="hljs-comment"> * while (i.hasNext()) v[f()] = i.next();</span>
<span class="hljs-comment"> */</span></code></pre>
<br/>


<h2 id="14-Partition-List"><a href="#14-Partition-List" class="headerlink" title="14. Partition List"></a>14. Partition List</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-list/">86. Partition List</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出链表和标准值 <code>x</code> ，要求对链表进行处理，使小于 x 的节点都出现在大于或等于 x 的节点之前。（保留每个节点的初始相对位置）</p>
<p><strong>题目解答：</strong></p>
<p>双指针扫描：用一个指针用于遍历链表，另一个指针记录当前小于 x 的链表当前位置。如果遇到小于 x 的节点，将其接到当前链表最后即可。</p>
<p>时间复杂度：$O(n)$，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * public class ListNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     ListNode next;</span>
<span class="hljs-comment"> *     ListNode() &#123;&#125;</span>
<span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;
        ListNode ret = <span class="hljs-keyword">new</span> ListNode(Integer.MIN_VALUE);
        ret.next = head;
        
        ListNode node = ret, current = ret;
        <span class="hljs-keyword">while</span>(node.next != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (node.next.val &lt; x) &#123;
                <span class="hljs-keyword">if</span> (current != node) &#123;
                    ListNode currentNext = current.next, nodeNext = node.next.next;
                    current.next = node.next;
                    node.next.next = currentNext;
                    node.next = nodeNext;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    node = node.next;
                &#125;
                current = current.next;
            &#125; <span class="hljs-keyword">else</span> &#123;
                node = node.next;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret.next;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="15-Fibonacci-Number"><a href="#15-Fibonacci-Number" class="headerlink" title="15. Fibonacci Number"></a>15. Fibonacci Number</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>求第 n 个（0-index）斐波那契数，斐波那契数由 0、1 开始，后面每个数字都是前两个数字之和。</p>
<p><strong>题目解答：</strong></p>
<p>递归的最常见的入门题之一，注意记忆即可。</p>
<p>时间复杂度：$O(n)$，空间复杂度：$O(n)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">31</span>];
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (ans[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans[n];
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans[n] = n;
        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>);
    &#125;
&#125;</code></pre>
<br/>



<h2 id="16-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#16-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="16. Remove All Adjacent Duplicates in String II"></a>16. Remove All Adjacent Duplicates in String II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/">1209. Remove All Adjacent Duplicates in String II</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给定字符串 s 和正整数 k，每次可以从字符串中删除 k 个相邻且相等的字母，删去后的字符串的左侧和右侧相连。要求重复进行无限次这样的删除操作，直到无法继续为止，并返回最终得到的字符串。（保证保证唯一）</p>
<p><strong>题目解答：</strong></p>
<p>使用栈结构即可，一旦遇到 k 个相同元素即出栈清除。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (!stack.empty() &amp;&amp; stack.peek().c == s.charAt(i)) &#123;
                stack.peek().cnt += <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                stack.add(<span class="hljs-keyword">new</span> Node(s.charAt(i), <span class="hljs-number">1</span>));
            &#125;
            
            <span class="hljs-keyword">if</span> (stack.peek().cnt &gt;= k) &#123;
                stack.pop();
            &#125;
        &#125;
        
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span>(!stack.empty()) &#123;
            Node node = stack.pop();
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; node.cnt; i++) &#123;
                sb.insert(<span class="hljs-number">0</span>, node.c);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> sb.toString();
    &#125;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> c;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> cnt;
        
        Node(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> cnt) &#123;
            <span class="hljs-keyword">this</span>.c = c;
            <span class="hljs-keyword">this</span>.cnt = cnt;
        &#125;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="17-Number-of-Submatrices-That-Sum-to-Target"><a href="#17-Number-of-Submatrices-That-Sum-to-Target" class="headerlink" title="17. Number of Submatrices That Sum to Target"></a>17. Number of Submatrices That Sum to Target</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/">1074. Number of Submatrices That Sum to Target</a> <code>Hard</code></p>
<p><strong>题目简述：</strong></p>
<p>给出二维数组和目标值，求二维数组含有多少元素和为 target 的子二维数组。</p>
<p><strong>题目解答：</strong></p>
<p>二维前缀和：前缀和 + 四重迭代</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSubmatrixSumTarget</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = matrix.length, m = matrix[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;
                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j+<span class="hljs-number">1</span>] + dp[i+<span class="hljs-number">1</span>][j] - dp[i][j] + matrix[i][j];
            &#125;
        &#125;

        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x1 = <span class="hljs-number">0</span>; x1 &lt; n; x1++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x2 = x1+<span class="hljs-number">1</span>; x2 &lt; n+<span class="hljs-number">1</span>; x2++) &#123;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y1 = <span class="hljs-number">0</span>; y1 &lt; m; y1++) &#123;
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y2 = y1+<span class="hljs-number">1</span>; y2 &lt; m+<span class="hljs-number">1</span>; y2++) &#123;
                        <span class="hljs-keyword">if</span> (dp[x2][y2] - dp[x1][y2] - dp[x2][y1] + dp[x1][y1] == target) &#123;
                            ans ++;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>
<br/>



<h2 id="18-Remove-Nth-Node-From-End-of-List"><a href="#18-Remove-Nth-Node-From-End-of-List" class="headerlink" title="18. Remove Nth Node From End of List"></a>18. Remove Nth Node From End of List</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出单向链表，要求移除倒数第 n 个元素。</p>
<p><strong>提高</strong>：能否在一轮遍历中完成</p>
<p><strong>题目解答：</strong></p>
<p>双指针，使用距离为 n 的双指针遍历即可找到倒数第 n 个元素</p>
<p>时间复杂度：$O(L)$ ，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * public class ListNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     ListNode next;</span>
<span class="hljs-comment"> *     ListNode() &#123;&#125;</span>
<span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
        ListNode ret = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), l = ret, r = ret;
        ret.next = head;
        <span class="hljs-keyword">while</span>(r.next != <span class="hljs-keyword">null</span> &amp;&amp; n-- &gt; <span class="hljs-number">0</span>) &#123;
            r = r.next;
        &#125;

        <span class="hljs-keyword">while</span>(r.next != <span class="hljs-keyword">null</span>) &#123;
            r = r.next;
            l = l.next;
        &#125;
        l.next = l.next.next;
        <span class="hljs-keyword">return</span> ret.next;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="19-Combination-Sum-IV"><a href="#19-Combination-Sum-IV" class="headerlink" title="19. Combination Sum IV"></a>19. Combination Sum IV</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出互不相同的一组数字及目标值，可任意使用使用数组范围内的数字（每个数字不限次数），使之求和为目标值，求共有多少种取值方式（不同排序视为不同解答）。</p>
<p><strong>题目解答：</strong></p>
<p>动态规划公式：$dp[target] = \sum_{i=1}^{n} dp[target-nums[i]], dp[0] = 1$</p>
<p>注意遍历方式，需要按顺序遍历 n 的所有取值。尝试了好几次遇到 <code>target-n</code> 值再遍历的方式，会遇到重复解或不正确解（局部解）。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1001</span>];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; i++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums) &#123;
                <span class="hljs-keyword">if</span> (num &lt;= i) dp[i] += dp[i - num];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[target];
    &#125;
&#125;</code></pre>
<br/>

<h2 id="20-N-ary-Tree-Preorder-Traversal"><a href="#20-N-ary-Tree-Preorder-Traversal" class="headerlink" title="20. N-ary Tree Preorder Traversal"></a>20. N-ary Tree Preorder Traversal</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">589. N-ary Tree Preorder Traversal</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给出 N 叉树的根节点，求其节点值的先序遍历结果。</p>
<p><strong>提高：</strong> 递归写法非常简单，你是否能用迭代方式给出解答？</p>
<p><strong>题目解答：</strong></p>
<p>深度优先搜索、递归即可</p>
<pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">// Definition for a Node.</span>
<span class="hljs-comment">class Node &#123;</span>
<span class="hljs-comment">    public int val;</span>
<span class="hljs-comment">    public List&lt;Node&gt; children;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    public Node() &#123;&#125;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    public Node(int _val) &#123;</span>
<span class="hljs-comment">        val = _val;</span>
<span class="hljs-comment">    &#125;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span>
<span class="hljs-comment">        val = _val;</span>
<span class="hljs-comment">        children = _children;</span>
<span class="hljs-comment">    &#125;</span>
<span class="hljs-comment">&#125;;</span>
<span class="hljs-comment">*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;
        
        list.add(root.val);
        <span class="hljs-keyword">for</span>(Node node : root.children) &#123;
            preorder(node);
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="21-Triangle"><a href="#21-Triangle" class="headerlink" title="21. Triangle"></a>21. Triangle</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/">120. Triangle</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个三角形二维数组，从顶到底，对当前位置 <code>i</code> ，每次可以移动到下一层的 <code>i</code> 或 <code>i+1</code> 位置，求从顶到底的路径中，最小和为多少？</p>
<p><strong>提高</strong>：能否在 O(n) 空间复杂度内完成？</p>
<p><strong>题目解答：</strong></p>
<p>动态规划：每个位置只能从上一层同位置或前一位置移动得到，显然有：$dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]$，只需判断边界情况即可。</p>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; triangle.size(); i++) &#123;
            List&lt;Integer&gt; prevList = triangle.get(i-<span class="hljs-number">1</span>), list = triangle.get(i);
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; list.size(); j++) &#123;
                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;
                    list.set(j, list.get(j) + prevList.get(j));
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == list.size()-<span class="hljs-number">1</span>) &#123;
                    list.set(j, list.get(j) + prevList.get(j-<span class="hljs-number">1</span>));
                &#125; <span class="hljs-keyword">else</span> &#123;
                    list.set(j, list.get(j) + Integer.min(prevList.get(j-<span class="hljs-number">1</span>), prevList.get(j)));
                &#125;
            &#125;
        &#125;
        
        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : triangle.get(triangle.size()-<span class="hljs-number">1</span>)) &#123;
            ans = Integer.min(ans, num);
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="22-Brick-Wall"><a href="#22-Brick-Wall" class="headerlink" title="22. Brick Wall"></a>22. Brick Wall</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/brick-wall/">554. Brick Wall</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一堵墙中每行各个砖头的宽度，要求垂直切开整个墙（不能用两侧切），求最少需要切开多少块砖头。</p>
<p><strong>题目解答：</strong></p>
<p>Map 保存每个位置的空隙数量</p>
<p>时间复杂度：$O(nm)$，空间复杂度：$O(nm)$，其中 $n$ 是砖墙的高度，$m$ 是每行砖墙的砖的平均数量。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastBricks</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;
        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; bricks : wall) &#123;
            <span class="hljs-keyword">int</span> width = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bricks.size()-<span class="hljs-number">1</span>; i++) &#123;
                width += bricks.get(i);
                map.put(width, map.getOrDefault(width, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
            &#125;
        &#125;

        <span class="hljs-keyword">int</span> maxCnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(Integer num : map.values()) &#123;
            maxCnt = Integer.max(maxCnt, num);
        &#125;
        <span class="hljs-keyword">return</span> wall.size() - maxCnt;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="23-Count-Binary-Substrings"><a href="#23-Count-Binary-Substrings" class="headerlink" title="23. Count Binary Substrings"></a>23. Count Binary Substrings</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-binary-substrings/">696. Count Binary Substrings</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>给定只由 <code>0</code>、<code>1</code> 组成的字符串 s，计算具有相同数量 0 和 1 的且所有 0 和所有 1 都是连续的非空（连续）子字符串的数量。（不同位置但内容相同的子串视为不同的子串。</p>
<p><strong>题目解答：</strong></p>
<p>检查整个字符串，计算相邻且各自连续的 <code>0</code>、<code>1</code> 最大长度，其中 <code>0</code>、<code>1</code> 出现次数的较小值就是该范围内的子串数量，将所有结果相加即可。</p>
<p>时间复杂度：$O(n)$，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">int</span> zeros = <span class="hljs-number">0</span>, ones = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(i-<span class="hljs-number">1</span>)) &#123;
                ans += Integer.min(zeros, ones);
                <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;
                    ones = <span class="hljs-number">0</span>;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    zeros = <span class="hljs-number">0</span>;
                &#125;
            &#125;

            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;
                ones++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                zeros++;
            &#125;
        &#125;
        ans += Integer.min(zeros, ones);
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="24-Critical-Connections-in-a-Network"><a href="#24-Critical-Connections-in-a-Network" class="headerlink" title="24. Critical Connections in a Network"></a>24. Critical Connections in a Network</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/critical-connections-in-a-network/">1192. Critical Connections in a Network</a> <code>Hard</code></p>
<p><strong>题目简述：</strong></p>
<p>给定无向图（点的数量 + 无向边端点列表），该无向图目前所有节点相连，求找出图中所有 <em>“关键连接”</em>。（返回顺序不限）</p>
<p>关键连接 是指某些无向边，删除该无向边后某些点将无法访问其他某些点。</p>
<p><strong>题目解答：</strong></p>
<p>（待补充）</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">int</span>[] disc, low;
    <span class="hljs-keyword">int</span> time = <span class="hljs-number">1</span>;
    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    Map&lt;Integer,List&lt;Integer&gt;&gt; edgeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="hljs-keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;
        disc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        low = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            edgeMap.put(i, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());
        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; conn : connections) &#123;
            edgeMap.get(conn.get(<span class="hljs-number">0</span>)).add(conn.get(<span class="hljs-number">1</span>));
            edgeMap.get(conn.get(<span class="hljs-number">1</span>)).add(conn.get(<span class="hljs-number">0</span>));
        &#125;
        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> ans;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curr, <span class="hljs-keyword">int</span> prev)</span> </span>&#123;
        disc[curr] = low[curr] = time++;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : edgeMap.get(curr)) &#123;
            <span class="hljs-keyword">if</span> (disc[next] == <span class="hljs-number">0</span>) &#123;
                dfs(next, curr);
                low[curr] = Math.min(low[curr], low[next]);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != prev)
                low[curr] = Math.min(low[curr], disc[next]);
            <span class="hljs-keyword">if</span> (low[next] &gt; disc[curr]) 
                ans.add(Arrays.asList(curr, next));
        &#125;
    &#125;
&#125;
</code></pre>
<br/>

<h2 id="25-Rotate-Image"><a href="#25-Rotate-Image" class="headerlink" title="25. Rotate Image"></a>25. Rotate Image</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/">48. Rotate Image</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出一个二维正方形数组（宽高相等），将其原地 90 度旋转。</p>
<p><strong>题目解答：</strong></p>
<p>原地旋转：直接原地交换四个位置的值即可，注意交换范围是左上角高 <code>n/2</code>，宽 <code>(n+1)/2</code> 范围内。</p>
<p>时间复杂度：$O(N^2)$，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = matrix.length, k = (n/<span class="hljs-number">2</span>)+(n%<span class="hljs-number">2</span>), r = k-(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; r; j++) &#123;
                <span class="hljs-keyword">int</span> temp = matrix[i][j];
                matrix[i][j] = matrix[n-j-<span class="hljs-number">1</span>][i];
                matrix[n-j-<span class="hljs-number">1</span>][i] = matrix[n-i-<span class="hljs-number">1</span>][n-j-<span class="hljs-number">1</span>];
                matrix[n-i-<span class="hljs-number">1</span>][n-j-<span class="hljs-number">1</span>] = matrix[j][n-i-<span class="hljs-number">1</span>];
                matrix[j][n-i-<span class="hljs-number">1</span>] = temp;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="26-Furthest-Building-You-Can-Reach"><a href="#26-Furthest-Building-You-Can-Reach" class="headerlink" title="26. Furthest Building You Can Reach"></a>26. Furthest Building You Can Reach</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/furthest-building-you-can-reach/">1642. Furthest Building You Can Reach</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给你一个整数数组 heights ，表示一排建筑物的高度。另有 bricks 数量的砖块  和 ladders 数量的梯子。</p>
<p>你从建筑物 0 开始旅程，不断向后面的建筑物移动，求最远可以到达的建筑物的下标。</p>
<p>当从建筑物 i 移动到建筑物 i+1 时：</p>
<ul>
<li>如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块</li>
<li>如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块</li>
</ul>
<p><strong>题目解答：</strong></p>
<p>（待补充）</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> bricks, <span class="hljs-keyword">int</span> ladders)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = heights.length;
        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len-<span class="hljs-number">1</span>; i++) &#123;
            <span class="hljs-keyword">int</span> diff = heights[i+<span class="hljs-number">1</span>] - heights[i];
            <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span> (ladders &gt; <span class="hljs-number">0</span>) &#123;
                    queue.add(diff);
                    ladders--;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queue.isEmpty() &amp;&amp; diff &gt; queue.peek()) &#123;
                    queue.add(diff);
                    bricks -= queue.poll();
                &#125; <span class="hljs-keyword">else</span> &#123;
                    bricks -= diff;
                &#125;
                <span class="hljs-keyword">if</span> (bricks &lt; <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">return</span> i;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> len-<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="27-Power-of-Three"><a href="#27-Power-of-Three" class="headerlink" title="27. Power of Three"></a>27. Power of Three</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-three/">326. Power of Three</a> <code>Easy</code></p>
<p><strong>题目简述：</strong></p>
<p>判断给出的数是否是 3 的幂</p>
<p><strong>提高：</strong> 是否能不适用循环/递归实现？</p>
<p><strong>题目解答：</strong></p>
<p>循环：循环做整除即可</p>
<p>时间复杂度：$O(log_b(n))$，空间复杂度：$O(1)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span> &amp;&amp; n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;
            n /= <span class="hljs-number">3</span>;
        &#125;
        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>
<br/>

<h2 id="28-Unique-Paths-II"><a href="#28-Unique-Paths-II" class="headerlink" title="28. Unique Paths II"></a>28. Unique Paths II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出二维数组，其中包含 0、1 两种取值，1 代表障碍物，不能行走。路径上没有障碍物的情况下，每次可以向右或向下行进一格，求从左上角到右下角共有多少种不同走法。</p>
<p><strong>题目解答：</strong></p>
<p>递归判断，并注意记忆结果</p>
<blockquote>
<p>这道题答错好几次，主要问题在于：</p>
<ol>
<li>没有考虑开始结束位置为障碍物的情况；</li>
<li>判断的顺序不对，没有把越界判断放在最前面，一开始把 <code>x==0 &amp;&amp; y==0</code> 写在最前面，完全没考虑 <code>obstacleGrid[x][y] == 1</code> 的可能性，当然加上这个判断也是一个办法，但从通用写法的角度考虑，把特殊值的情况放在越界判断后面显然是更合理一点的。</li>
</ol>
</blockquote>
<p>时间复杂度：$O(M \times N)$，空间复杂度：$O(M \times N)$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m, n;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] res;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.m = obstacleGrid.length;
        <span class="hljs-keyword">this</span>.n = obstacleGrid[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">this</span>.res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
            Arrays.fill(res[i], -<span class="hljs-number">1</span>);
        &#125;
        res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m-<span class="hljs-number">1</span>, n-<span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= m || y &lt; <span class="hljs-number">0</span> || y &gt;= n || obstacleGrid[x][y] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (res[x][y] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res[x][y];

        <span class="hljs-keyword">return</span> res[x][y] = uniquePathsWithObstacles(obstacleGrid, x-<span class="hljs-number">1</span>, y) + uniquePathsWithObstacles(obstacleGrid, x, y-<span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre>
<br/>

<h2 id="29-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#29-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="29. Find First and Last Position of Element in Sorted Array"></a>29. Find First and Last Position of Element in Sorted Array</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出升序排序的数组，求目标数字 <code>target</code> 在数组中的开始和结束位置，如果数组中不存在该数字，则返回 <code>[-1, -1]</code></p>
<p><strong>提高</strong>：是否能在 <code>O(log n)</code> 时间复杂度内完成？</p>
<p><strong>题目解答：</strong></p>
<p>本题可以看作寻找第一个等于 target 的位置，与第一个大于 target 的位置，因此可以通过两次二分实现。</p>
<p>时间复杂度：<code>O(log n)</code>，空间复杂度：<code>O(1)</code></p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;
        <span class="hljs-keyword">int</span> l = binarySearch(nums, target, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">int</span> r = binarySearch(nums, target, <span class="hljs-keyword">false</span>) - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 二分找到的是第一个大于 targer 的位置，因此还需要减一</span>
        
        <span class="hljs-keyword">if</span> (l &lt;= r &amp;&amp; r &lt; nums.length &amp;&amp; nums[l] == target &amp;&amp; nums[r] == target) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l, r&#125;;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;
    &#125;
    
    <span class="hljs-comment">// lower 为 true 表示寻找的是等于 targer 的第一个值</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">boolean</span> lower)</span> </span>&#123;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>, ans = nums.length;  <span class="hljs-comment">// ans 初始值为 nums.length，即没有值大于 target 时的默认结果。</span>
        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;
            <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;

            <span class="hljs-comment">// 由完整表达式简化得到：(!lower &amp;&amp; nums[mid] &gt; target) || (lower &amp;&amp; nums[mid] &gt;= target)</span>
            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;
                r = mid-<span class="hljs-number">1</span>;
                ans = mid;
            &#125; <span class="hljs-keyword">else</span> &#123;
                l = mid+<span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;
</code></pre>
<br/>

<h2 id="30-Powerful-Integers"><a href="#30-Powerful-Integers" class="headerlink" title="30. Powerful Integers"></a>30. Powerful Integers</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/powerful-integers/">970. Powerful Integers</a> <code>Medium</code></p>
<p><strong>题目简述：</strong></p>
<p>给出 <code>x</code>、<code>y</code> 和 <code>bound</code>，求在不超过 <code>bound</code> 的范围内有哪些值满足 $x^i + y^j, (i &gt;= 0, j &gt;= 0)$ 。（返回值不要求顺序，但同一值不能重复出现）</p>
<p><strong>题目解答：</strong></p>
<p>暴力（广度优先搜索）：暴力计算所有 $x^i + y^j$ 的值即可，此处用队列方式搜索所有组合。</p>
<p>时间复杂度：$O(\log^2{\text{bound}})$，空间复杂度：$O(\log^2{\text{bound}})$</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">powerfulIntegers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> bound)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (bound &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Collections.emptyList();
        
        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Set&lt;Pair&lt;Integer, Integer&gt;&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        Set&lt;Integer&gt; ansSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;);
        set.add(<span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));
        <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;
            <span class="hljs-keyword">int</span>[] arr = q.poll();
            <span class="hljs-keyword">if</span> (!ansSet.contains(arr[<span class="hljs-number">0</span>])) &#123;
                ans.add(arr[<span class="hljs-number">0</span>]);
                ansSet.add(arr[<span class="hljs-number">0</span>]);
            &#125;
            
            <span class="hljs-keyword">long</span> num;
            <span class="hljs-keyword">if</span> ((num = arr[<span class="hljs-number">1</span>] * x + arr[<span class="hljs-number">2</span>]) &lt;= bound &amp;&amp; !set.contains(<span class="hljs-keyword">new</span> Pair&lt;&gt;(arr[<span class="hljs-number">1</span>] * x, arr[<span class="hljs-number">2</span>]))) &#123;
                set.add(<span class="hljs-keyword">new</span> Pair&lt;&gt;(arr[<span class="hljs-number">1</span>] * x, arr[<span class="hljs-number">2</span>]));
                q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;(<span class="hljs-keyword">int</span>)num, arr[<span class="hljs-number">1</span>] * x, arr[<span class="hljs-number">2</span>]&#125;);
            &#125;
            <span class="hljs-keyword">if</span> ((num = arr[<span class="hljs-number">1</span>] + arr[<span class="hljs-number">2</span>] * y) &lt;= bound &amp;&amp; !set.contains(<span class="hljs-keyword">new</span> Pair&lt;&gt;(arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>] * y))) &#123;
                set.add(<span class="hljs-keyword">new</span> Pair&lt;&gt;(arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>] * y));
                q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;(<span class="hljs-keyword">int</span>)num, arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>] * y&#125;);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;
</code></pre>
<br/>

    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    </div>
    
    
    <script>
        hljs.initHighlightingOnLoad();
    </script>
</body>
</html>
